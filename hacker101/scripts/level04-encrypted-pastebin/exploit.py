#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import requests
from base64 import b64encode, b64decode
from binascii import hexlify, unhexlify
from math import ceil

def _pad(text, block_size):
    no_of_blocks = ceil(len(text)/float(block_size))
    pad_value = int(no_of_blocks * block_size - len(text))

    if pad_value == 0:
        return text + chr(block_size) * block_size
    else:
        return text + chr(pad_value).encode() * pad_value


def xor(args):
    # Sort by len DESC
    args.sort(key=len, reverse=True)
    res = bytearray(args.pop(0))
    maxlen = len(res)

    for s in args:
        slen = len(s)
        for i in range(maxlen):
            res[i] ^= s[i % slen]
    return res


def from_str(s):
    res = b''
    for char in s.encode("utf-8").decode("unicode_escape"):
        res += bytes([ord(char)])
    return res


def get(data):
    url = 'https://2e0103df42b4a940a9dc1da7cdad7900.ctf.hacker101.com/'

    b64 = b64encode(data).decode().replace('=', '~').replace('/', '!').replace('+', '-')
    url += '?post=' + b64
    r = requests.get(url)
    print('-'*64)
    print(r.text)


def inject(txt):
    plain = from_str('{"flag": "^FLAG^')
    crypt = bytes.fromhex('d2c6dd4c2a41f7ed5f0408ef4e31721dde55d1674026226fad1b7c11f0be754b')
    IV = crypt[:block_size]

    newplain = _pad(txt.encode(), block_size)[:block_size]
    print("Plain     %s %s" % (hexlify(plain).decode(), plain))
    print("New Plain %s %s" % (hexlify(newplain).decode(), newplain))
    print("IV        %s" % (hexlify(IV).decode()))

    newIV = xor([plain, newplain, IV])
    print("newIV     %s" % hexlify(newIV).decode())

    return newIV + crypt[block_size:2*block_size]

if __name__ == "__main__":
    block_size = 16

    if len(sys.argv)>1:
        txt = sys.argv[1]
    else:
        txt = '{"id":"1"}'

    data = inject(txt)
    get(data)
